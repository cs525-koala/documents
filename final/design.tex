\section{Design}
\label{sec:design}

\KComment{In general, many parts of the design are not motivated: they are just
presented as is. This makes it difficult to convince the reader that the
design decisions were in fact the best ones possible.}

\KComment{Sec 3 presents several different components: it is not clear however
why you absolutely need these different components. Give examples here to make
the motivation clearer.}

\KComment{Add design intro}

    Koala's primary addition to Eucalyptus is its dynamic scheduler.  The scheduler attempts to improve resource utilization by reallocating resources on-the-fly.  To support this, Koala consists of two additional components: live migration support, and performance monitoring infrastructure.


Figure~\ref{fig:Koala} shows these components and where they fit into the
overall system architecture, and we describe each of them below.

\scalefig{Koala}{0.9}{Koala System Overview}

\subsection{Live Migration}
\KComment{This burns me}
Live migration is the process of transparently moving a running VM between two
machines.  In Koala, in order to efficiently manage the resources of a cloud,
we need to be able to move VMs around to put them in a desired configuration.
This must be done without disrupting the internal state of the VM, any active
network connections, and that while moving VMs we have minimal downtime.  Koala
uses live migration to achieve this.  This live migration primitive is a key
part of the Koala architecture, enabling the other components to dynamically
manage the resources of the cluster.

\subsection{Performance Monitoring}
\KComment{WRITE ME}

\subsection{Parameterized Scheduler}
\KComment{Sec 3.2 is rather vague and abstract: please tighten.
information..configuration parameters..some optimality metric.¹ What
monitoring information is used? Which configuration params are set (and why
only those)? What optimality metrics? Give examples.}

The most important part of Koala is its dynamic scheduler.  The addition of this
scheduler enables Koala to make better use of the available resources, and to
respond to changing loads and system conditions.

In Koala, we used the performance monitoring infrastructure to answer the
question ``How well is our cloud performing'', and attempt to improve upon it by
leveraging live migration to reallocate resources and improve the overall
system.

For a given configuration $C$ (assignment of instances to nodes), and
monitoring information $M$, we define a score $Score(M,C)$ for the system.  This
score represents how well the resources of our system are being utilized, and we
define a higher score to mean a better resource allocation.

Our scheduling algorithm then works as follows:

\begin{algorithm}
\caption{Koala's Scheduler}
\label{algo:sched}
\footnotesize
\begin{algorithmic}
\Procedure{Schedule}{$M$, $C$, $D$}
    \State $best \gets \{C,Score(M,C)\}$%\Comment{Track best}
    \ForAll{$Instances~I, Nodes~N$}
        \State $C' \gets C : (I \gets N)$
        \If{$isIllegal(C')$}
            \State $skip$
        \EndIf
        \State $S \gets Score(M,C') - migrationCost(\dots)$
        \State $best = max(best,\{C',S\})$
        \If{$D > 1$} %\Comment{Look another step ahead}
        \State $\{C'',S\} \gets Schedule(M,C',D-1)$
        \State $best = max(best,\{C', S - Penalty(\dots)\})$
        \EndIf
    \EndFor
    \State \textbf{return} $best$
\EndProcedure
\end{algorithmic}
\normalsize
\end{algorithm}

The scoring function in Koala works as follows:

\begin{algorithm}
\caption{System Scoring}
\label{algo:score}
\footnotesize
\begin{algorithmic}
\Procedure{Score}{$M$, $C$}
    \State $S \gets 0$
    \ForAll{$Nodes~N, Resources~R$}
        \State $C \gets M.theoryUsed(R,N) - M.avail(R,N)$
        \State $S \gets S + max(C,0)$
    \EndFor
    \State \textbf{return} $S$
\EndProcedure
\end{algorithmic}
\normalsize
\end{algorithm}

Koala has a parameterized scheduler.  The primary goal of the scheduler is to
manage the assignment of VMs to nodes in an attempt to achieve a more desirable
system.  The scheduler has two components, a static scheduler and the dynamic
scheduler.  The static scheduler answers the question ``on which node should
this instance start?'', while the dynamic scheduler answers the more
complicated question ``Is there some migration that would result in a more
optimal configuration?''.  The dynamic scheduler needs to take into account
many things, such as the cost of migration and what it means to be an optimal
configuration.  This is a challenge because distributed systems are hard to
predict, especially when building a general scheduler.  Koala handles this in
its scheduler by exposing the various weights and configuration knobs into
scheduling parameters that can be changed at runtime to make decisions.  In
exposing these parameters, we attempt to abstract as many assumptions as
possible into configurable values that enable the scheduler to be as general it
can be.

\subsection{Dynamic Learning}
\KComment{Sec 3.3 is abstract and says that Œit uses monitoring}
Given our parameterized scheduler, we have the task of setting the
configuration values to something reasonable for a particular system and set of
workloads, all of which might change dynamically.  We believe asking the user
to set these values imposes an unreasonable burden, due to both the complexity
of such a task and the ever-changing needs of an Eucalyptus system.  Koala
simplifies this task by leveraging learning algorithms.  It uses monitoring
information to attempt to find ideal values for the configuration parameters,
with respect to some optimality metric.  The problem of how to determine the
optimality metric is in itself, a complicated issue.  This is due to the fact
that there are many different definitions of optimal (attempts to reduce power
consumption might be at odds with attempts to increase system performance), and
so we generalize these to a smaller set of knobs which are exposed to the
end-user.  This greatly simplifies the burden on the user, and because this too
is dynamically configurable, can allow for greater control of the system as
requirements and priorities change.

\subsection{Summary}

Koala has three components, all of which build upon each other.  The addition
of live migration allows dynamic resource management, but is far too
complicated for Eucalyptus's primitive scheduler to reason about.  The
parameterized scheduler attempts to uses live migration to achieve a more
desirable system configuration, but exposes a new challenge in the form of
configurable parameters.  Learning algorithms, when provided sufficient data
and optimality metrics, should provide near optimal scheduling parameters.  We
believe this is a powerful combination that not only greatly simplifies and
automates the resource management of the cluster, but also enables
significantly improved resource utilization than would otherwise be possible.
