\section{Introduction}
\label{sec:intro}
\KComment{What is the concrete problem statement you are solving? Please state this clearly in the introduction.}

   Modern computing needs have grown to require the execution of larger and more complex tasks, which require more storage and computational power than ever before.  Cloud computing has emerged as both a topic in research and industry, and strives to provide the best platform for these tasks given a set of resources to run them on.  Cloud computing is closely tied with its roots in distributed and grid computing systems and has significant overlap with them.  

  Eucalyptus is a popular cloud computing system, which allows for a transparent deployment of virtual machines (VMs) across a large variety of systems (usually in the form of a cluster or set of clusters) and also provides a consistent interface to access these systems.  From the perspective of Eucalyptus, the contents of an individual VM is seen only as a black box.  Due interactions outside scope of Eucalyptus, the execution of these VMs can change at any time.  Eucalyptus also has no control over when new VMs are requested and has no knowledge of when they will be shut down.

Despite this limited knowledge, Eucalyptus is tasked with scheduling these VMs with some level of optimality.  Finding a good configuration of these VMs is critical to achieving high utilization of the systems resources or consuming less power.  Eucalyptus uses a scheduler to assign VMs to specific computers, which has three different modes: a greedy scheduler, which places the VM in the first available computer it can find, a round-robin scheduler, which attempts to balance the load across machines by distributing the VMs between the computers in a cluster, and a power-saving mode, which uses the greedy scheduler for allocation, but also looks at usage thresholds and attempts to power down machines.

  Although Eucalyptus goes a long way in the way of providing transparent deployment and management, its use of a static scheduler is limited in its ability.  VMs can run for days, weeks, months, or years.  Additionally, these VMs can stress or saturate none or all of the resources provided to them.  Eucalyptus (or any other VM management system) has only a limited view of the VMs, and cannot be expected to know details of their execution or duration.  As new VMs are added and removed or their execution patterns change, the configuration in which Eucalyptus placed the VMs will quickly diverge from an optimal configuration.

For example, if there are 4 VMs to be scheduled across two machines, Eucalyptus will distribute them across these machines in a reasonable fashion.  With the round-robin scheduler, it would likely end up with 2 VMs on each of the two machines.  After this, it has no ability to change the system.  Even without the addition of new VMs or the removal of existing VMs, there are many ways in which this is non-optimal.  If the 2 VMs on the first machine has little to no CPU load and the 2 VMs on the second machine are contending for CPU resources, it is obvious that this configuration could be improved.  More generally, given a VM's dynamic need for resources (CPU, disk, memory, network,b etc), static assignment of VMs is fundamentally insufficient in a high performance cloud.

A naive dynamic scheduler could terminate and redeploy VMs elsewhere in an attempt to reach a better configuration;  however, the contents of the VMs are unknown to Eucalyptus, and such behavior would be unacceptable in most cases.  VM migration, an established technique in VM-based systems, offers a more robust solution to this problem.  VM migration allows VMs to be moved between different computers.  Traditionally, this involved pausing a VM and moving it to another computer, where it could be resumed.  Live migration is a subset of VM migration, where this migration is transparent to an outside observer.  As Eucalyptus is unaware of the execution, connections, and internal state associated with the VMs, it is not able to assume a non-live migration is acceptable.  

A large cloud, which encompasses numerous VMs, is very difficult to reason about in a scheduler.  Hundreds, if not thousands of VMs, will be sharing the resources of a large number of machines.  How to issue migrations in order to improve the overall configuration is a very non-trivial task.  

Machine learning algorithms provide a means by which such complex tasks can be attempted.  Given a representative set of training data, these algorithms can make intelligent decisions which are otherwise very difficult to model.

%mostly stolen from the abstract, might want to diverge more
To address these issues, we present \emph{Koala}, an enhanced Eucalyptus system which uses live migration and a dynamic scheduler to greatly improve resource utilization within a cluster.  Utilizing the benefits provided from live migration, Koala's dynamic scheduler can make effective and reactive scheduling decisions that were not possible by the basic Eucalyptus system.  Additionally, Koala's use of learning algorithms allow it to optimize the configuration of the scheduler and make it robust to changing needs and demands on the cluster.

The rest of the paper is organized as follows.  In Section~\ref{sec:background}, describe the various components of Eucalyptus.  Section~\ref{sec:design} presents the design of our system, and the implementation details are described in Section~\ref{sec:impl}.  The evaluation of Koala is presented in Section~\ref{sec:eval}.  Section~\ref{sec:related} discusses related work, and concluding remarks are provided in Section~\ref{sec:conclusion}.% Wording is terrible :P


%As clouds increase in scale, the adding and removing of VMs will result in fragments of poorly allocated or completely unallocated resources.  Additionally, the execution patterns of the VMs are likely unique and will change unpredictably.  Even assuming that an optimal VM organization existed and was known by the scheduler, any form of migration has both a duration and a cost, and assuming the scheduler could reach this configuration before it changed simply is not reasonable.  One the other hand, by only considering configurations one migration away from the current configuration, the scheduler could become stuck at a locally optimum configuration.  The best way in which to approach an optimal configuration is non-deterministic, and the questions of if, when, where from, and where to issue a migration is an extremely complicated task.
%need to carefully word this to make sense - this is a big selling point for learning algorithms
